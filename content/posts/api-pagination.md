+++
title = 'Api Pagination'
date = 2024-03-15T16:29:38+02:00
draft = false
+++

Пагинация на бэкенде полезна при работе с большими объемами данных.  
В случаях когда на фронтенде уже нет возможности загрузить весь объем данных и управлять им на помощь придет бэкенд пагинация.  
Ниже посмотрим на способы организации пагинации на бэкенде.  

## Pagination methods

### Offset and limit pagination

Самый прямолинейный и простой способ. Мы предоставляем пользователю API параметра `limit` и `offset`.  
Подход к выдаче нужной страницы будет выглядеть так:  

1. Получаем выборку всех подходящих под запрос данных.
2. Пропускаем количество записей с начала, которое указано в параметре `offset`.
3. После пропуска параметров выдаем количество записей, указанное в параметре `limit`.

Посмотрим на примере `limit = 2` и `offset = 4`.  
Первые четыре записи будут пропущены и две после них отобраны в результат.  

| record_id | action |
| --------- | ------ |
| 1         | skip   |
| 2         | skip   |
| 3         | skip   |
| 4         | skip   |
| 5         | take   |
| 6         | take   |
| ...       |        |

В SQL для этого есть соответствующие ключевые слова `limit` и `offset`.  
В MongoDB можно использовать `limit` и `skip` или же `slice` для подобного.  

Плюсы:  

- Простой подход.
- Возможно выполнить переход на любую страницу и запрашивать страницы параллельно.
- Нет состояния. Нужная страница определяется только через `limit` и `offset`.

Минусы:  

- Может возвращать разный набор записей при повторном запросе одной и той же страницы.
- Ключевое слово SQL `offset` все равно требует выборки `offset + limit` записей. Следовательно, при большом `offset` обработка запроса может требовать больше ресурсов и времени. ([OFFSET in postgres](https://www.postgresql.org/docs/current/queries-limit.html), [LIMIT in mysql](https://dev.mysql.com/doc/refman/8.0/en/limit-optimization.html)).

### Keyset pagination

Более сложный способ, но дает больше стабильности и лучше масштабируется.  

Суть состоит в том, чтобы вместе с каждым набором результатов давать ключ для получения следующей страницы. Ключ это значение в поле поиска с которого нужно будет возвращать результаты. Для этих целей нужно будет добавить значения `since`  и `limit` в запрос выдачи результатов.  
В ответе на каждый запрос придется выдавать ключ для начала следующей страницы результатов `since_next`.  
Например, имеем таблицу с полем поиска `record_id`:  

| record_id | data   |
| --------- | ------ |
| 1         | data 1 |
| 2         | data 2 |
| 3         | data 3 |
| 4         | data 4 |
| 5         | data 5 |
| 6         | data 6 |
| ...       |        |

Запрос первых двух результатов потребует параметров `since=null` и `limit=2`, а в ответе мы получим `since_next=3`.  
Запрос следующей страницы уже будет выглядеть так: `since=3` `limit=2`. И так далее до тех пор пока `since_next` не окажется пустым.  

Такой подход можно подстроить под любые нужды. Если в поле поиска будет временная метка записи и сортировка по убыванию, то в первой странице всегда будут самые новые записи.  
Если в поле поиска будет порядковый номер и сортировка по возрастанию, то новые записи будут оказываться в конце.  

Плюсы:  

- Стабильная выдача вне зависимости от добавления/удаления данных.
- Такой подход может эффективно работать и при большом количестве данных.

Минусы:  

- Требуется упорядоченный тип данных в поле по которому будет вестись поиск.
- Для хорошей производительности в случае использования реляционных баз требуется индекс по полю поиска.
- Нельзя просто получить любую страницу. (Технически, конечно можно, но это ненадежно.) Плюс ко всему вряд ли удастся параллельно запрашивать страницы.
- Такой подход может раскрывать внутреннее устройство данных.

### Cursor based pagination

Обобщение keyset pagination которое может упростить жизнь разработчикам.  
Мы точно также как и в предыдущем способе в ответ помещаем значение для получения следующей страницы. Только в данном случае это значение уже не просто ключ таблицы, а курсор.  
Курсор это указатель на позицию в наборе данных. Он должен быть неявным и передаваться в неизменном виде.  
Самое интересное, что под значением курсора могут быть скрыты разные механизмы пагинации.  

Рассмотрим пару вариантов курсоров на примере. Будем использовать тот же набор полей, что и в предыдущем случае: `since_next`, `since` и `limit`.  

| record_id | data   |
| --------- | ------ |
| 1         | data 1 |
| 2         | data 2 |
| 3         | data 3 |
| 4         | data 4 |
| 5         | data 5 |
| 6         | data 6 |
| ...       |        |

Запрос первой страницы `since=null` `limit=2`. В ответ получим две записи и `since_next=eyJvZmZzZXQiOiAyfQo=`.  
Запрос второй страницы `since=eyJvZmZzZXQiOiAyfQo=` `limit=2`. В ответ получим еще 2 записи и `since_next=eyJvZmZzZXQiOiA0fQo=`.  

В данном случае под курсором скрыта offset/limit пагинация. Значение `since_next` это json в формате base64.  

```bash
echo '{"offset": 2}' | base64 -> eyJvZmZzZXQiOiAyfQo=
echo '{"offset": 4}' | base64 -> eyJvZmZzZXQiOiA0fQo=
```

По аналогии, под курсором может скрываться и keyset пагинация.  

Плюсы:  

- Все плюсы keyset пагинации.
- Позволяет изменять способ пагинации не меняя API.

Минусы:  

- Более сложная реализация.
- Для получения страницы `N` нужно будет выполнить столько же запросов.
- Сложно отлаживать при разработке.
