+++
title = 'DBMS Isolation Levels'
date = 2023-10-06T22:01:30+03:00
draft = false
tags = ['dbms']
+++

У баз данных обычно выделяют четыре уровня изоляции:

1. Read Uncommitted
2. Read Commited
3. Repeatable Read
4. Serializable

А придумано все это чтобы справится с пятью основными феноменами:  
**Dirty write** - Изменяющие запросы могут перезаписывать друг друга внутри даже из незавершенных транзакций. Любой уровень изоляции защищает от этой проблемы.  
**Dirty read** - Транзакция может прочитать данные другой незавершенной транзакции.  
**Non repeatable read** - Два чтения данных в одной транзакции возвращают измененные наборы данных.  
**Phantom read** - Два запроса получают разные наборы строк.  
**Serialization anomaly** - Это случай когда результат от набора транзакций зависит от порядка их применения.  

А вот карта того какой уровень изоляции от чего защищает.

| Isolation Level  | Dirty Read   | Non repeatable Read | Phantom Read | Serialization Anomaly |
| ---------------- | ------------ | ------------------- | ------------ | --------------------- |
| Read uncommitted | Possible     | Possible            | Possible     | Possible              |
| Read committed   | Not possible | Possible            | Possible     | Possible              |
| Repeatable read  | Not possible | Not possible        | Possible     | Possible              |
| Serializable     | Not possible | Not possible        | Not possible | Not possible          |

Посмотрим подробнее уровни изоляций, их отличия и когда какой стоит использовать. Пойдем в направлении увеличения строгости.

## Read Uncommitted

Минимальный уровень изоляции. На этом уровне запрещены только dirty writes. 
Этот уровень редко используется в коде приложений. Чаще его используют при ручном доступе в базу чтобы не заблокировать работающее приложение. Еще можно использовать для поиска ошибок при работе приложения с базой.
На этом уровне DBMS практически не использует локи, поэтому выборка данных здесь может оказаться быстрее чем в других уровнях. Если ни одна из перечисленных проблем не является критичной или нет требований к точности данных (например, достаточно только примерно оценить количество строк в базе), то этот уровень можно использовать. 

## Read Committed

Уровень изоляции по-умолчанию во многих DBMS. 
На этом уровне изоляции уже не может быть dirty reads, следовательно мы получаем гарантию, что прочитаем только закоммиченные данные. Однако, мы все равно можем получить разные данные при повторении одного и того же запроса.
Если в общих словах, то при работе с данными создается лок на данных, которые мы собираемся изменять. Это означает, что на каждый запрос INSERT, DELETE или UPDATE DBMS создаст внутри себя мьютекс, привязанный к изменяемым данным. Этот мьютекс будет ограничивать любые другие запросы от операций с этими данными до окончания изменяющей транзакции. Интересный момент в том, что на SELECT запросы тоже создается мьютекс, но он удаляется после окончания работы запроса, а не транзакции(!).

## Repeatable Read

Этот уровень изоляции предоставляет нам гарантию, что мы будем оперировать данными, которые были на момент старта транзакции. Другими словами, внутри транзакции мы будем получать одни и те же данные сколько бы мы не повторяли запрос. На этом уровне проблема non repeatable read уходит. Строки, которые мы уже прочитали останутся теми же, даже если в другой транзакции произойдет их изменение. Однако, мы все равно сможем прочитать новые добавленные строки (phantom read).
Такое поведение может быть реализовано разными способами.
Например, в [postgres в момент начала транзакции создается снапшот данных](https://www.interdb.jp/pg/pgsql05.html) и вся работа происходит с ним.
А в [innodb любой запрос на изменение создает локи ](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)и не отпускает их до конца транзакции. Кстати, в innodb [этот уровень является дефолтным](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#:~:text=The%20default%20isolation%20level%20for,with%20the%20SET%20TRANSACTION%20statement.).

Этот уровень изоляции стоит использовать в случае, когда хочется быть уверенным, что данные не изменятся пока мы с ними работаем.

## Serializable

Максимальный уровень изоляции. Фантомного чтения больше не будет.
Сериализация означает полное отсутствие конкурентного доступа. То есть любые транзакции применяются одна после другой. На этом уровне нужно быть готовым ретраить запросы в базу или долго ждать завершения транзакции. Стоит использовать только когда считается недопустимым появление новых данных во время работы транзакции.
Конечно, и на этом уровне можно устроить конфликт между двумя транзакциями. Они называются аномалиями сериализации (можно поискать по словам write skew и read only write skew).

## Ссылки

- https://www.geeksforgeeks.org/transaction-isolation-levels-dbms/
- https://www.postgresql.org/docs/current/sql-set-transaction.html
- https://www.postgresql.org/docs/current/transaction-iso.html
- https://sqlperformance.com/2014/04/t-sql-queries/the-serializable-isolation-level
- https://wiki.postgresql.org/wiki/SSI
- https://www.javatpoint.com/dbms-lock-based-protocol
